"""

N64 Converter
comm.py
Copyright 2020 Riley Lannon

A file for interfacing between the Arduino and pyserial.
This will take the signals generated by the arduino (sent over serial) and convert them into mouse movements and keystrokes.

"""

# libraries
import serial
import serial.tools.list_ports
import pynput
import pyautogui
import sys
import glob

# custom modules
import serial_packet

def serial_ports():
    """ Lists serial port names

        :raises EnvironmentError:
            On unsupported or unknown platforms
        :returns:
            A list of the serial ports available on the system
    """
    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
        # this excludes your current terminal "/dev/tty"
        ports = glob.glob('/dev/tty[A-Za-z]*')
    elif sys.platform.startswith('darwin'):
        ports = glob.glob('/dev/tty.*')
    else:
        raise EnvironmentError('Unsupported platform')

    result = []
    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass
    return result

def update_keys(pressed_buttons, packet, keyboard, mouse, config):
    """ Updates which keys are up/down and where the mouse position is
    """
    incoming = list(packet)
    pressed = list(pressed_buttons)

    i = 0
    while i < incoming.__len__():
        # we only need to make a change if the data aren't the same
        if pressed[i] != incoming[i] and i != 7 and i != 8:
            # we will drive the mouse separately; skip these
            if i == 7:
                i += 1
            elif i == 8:
                pass
            else:
                if pressed[i]:
                    keyboard.release(config[i])
                else:
                    keyboard.press(config[i])
       
        # increment the index
        i += 1
    
    # now, update the mouse
    # get the old and new coordinates
    old_x_coord = pressed[7]
    new_x_coord = incoming[7]
    old_y_coord = pressed[8]
    new_y_coord = incoming[8]

    # we only want to change the position of the mouse if the coordinate switches quadrants
    # otherwise, we want to change the *speed* at which we are driving it
    mouse_pos = mouse.position
    
    # if the joystick returned to its default position, stop mouse movement
    if new_x_coord == 0 and new_y_coord == 0:
        pass
    else:
        print(new_x_coord)
        print(new_y_coord)
        y_change = 0
        x_change = 0

        if new_x_coord == 0:
            x_change = 0
        else:
            if 0 < new_x_coord <= 50:
                x_change = 1
            elif 50 < new_x_coord <= 100:
                x_change = 5
            elif 100 < new_x_coord < 127:
                x_change = 7
            elif 0 > new_x_coord >= -50:
                x_change = -1
            elif -50 > new_x_coord >= -100:
                x_change = -5
            elif -100 > new_x_coord >= -128:
                x_change = -7

        if new_y_coord == 0:
            y_change = 0
        else:
            if 0 < new_y_coord <= 50:
                y_change = 1
            elif 50 < new_y_coord <= 100:
                y_change = 5
            elif 100 < new_y_coord < 127:
                y_change = 7
            elif 0 > new_y_coord >= -50:
                y_change = -1
            elif -50 > new_y_coord >= -100:
                y_change = -5
            elif -100 > new_y_coord >= -128:
                y_change = -7
            
            # Since 0,0 is the top left corner, we need to invert the y axis
            y_change = -y_change
        
        mouse.move(x_change, y_change)

def main():
    # Create the mouse and keyboard
    mouse = pynput.mouse.Controller()
    keyboard = pynput.keyboard.Controller()

    # Create a default keyboard configuration, putting in 0 for mouse x and y (handled separately)
    # todo: allow user to supply their own configurations?
    default_config = ['q','w','e','r','t','y','u',0,0,'i','o','a','s','d','f','g']

    # we must first connect to the Arduino via serial
    # view which connections are available
    all_ports = serial_ports()

    listed_ports = list(serial.tools.list_ports.comports())
    arduino_port = ""

    for port in listed_ports:
        if "Arduino" in port.__str__():
            arduino_port = port.__str__()
            break

    if arduino_port == "":
        raise Exception("No Arduino detected")

    to_connect_name = ""
    for port in all_ports:
        if port in arduino_port:
            to_connect_name = port

    if to_connect_name == "":
        raise Exception("Could not find port")

    # connect to the serial port
    conn = serial.Serial(to_connect_name, 9600, timeout=3)
    if not conn.is_open:
        conn.open()

    
    # create the SerialPacket object
    packet = serial_packet.SerialPacket()

    # create an object to store controller data
    pressed_buttons = serial_packet.Buttons()

    # Reset the input buffer
    conn.reset_input_buffer();
    print("Connected.")

    # Our main loop
    quit = False
    while not quit:
        try:
            # read whole objects one at a time -- ensure that we can read the entire object
            if conn.in_waiting >= 18:
                # get the packet
                data = conn.read(18);
                packet.update(data)
                
                # update the keystrokes and current button data
                update_keys(pressed_buttons, packet.buttons, keyboard, mouse, default_config)
                pressed_buttons.update(list(packet.buttons))
        except:
            # When we get an exception, quit the program
            print("Something went wrong; perhaps the adapter came unplugged?")
            quit = True

if __name__ == "__main__":
    main()
